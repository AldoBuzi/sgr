<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Balanced PF_RING Dispatcher: Main Page</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Balanced PF_RING Dispatcher
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Balanced PF_RING Dispatcher Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="introduction"></a>
Introduzione</h2>
<p>Balanced PF_RING Dispatcher e' un software di bilanciamento coerente di traffico di rete pensato per analizzatori di traffico ma perfettamente utilizzabile anche per altri scopi.<br/>
 Grazie all'utilizzo dei socket PF_RING e di tecniche di hashing a basso costo computazionale e' in grado di funzionare anche su reti ad alto traffico, senza l'utilizzo di costose architetture proprietarie.<br/>
 Il caso d'uso piu' comune e' installarlo su una macchina che riceve il traffico di rete su un'interfaccia ( per brevita' ifIN ) e lo smista in modo coerente verso altre macchine che effettueranno l'analisi vera e propria attraverso N interfacce in uscita ( per brevita' ifOUT1 ... ifOUTN), la scelta dell'interfaccia di uscita sara' effettuata in modo da non inficiare l'integrita' dei flussi di rete e da bilanciare il piu' possibile il carico sulle interfacce in uscita.</p>
<h2><a class="anchor" id="usage"></a>
Utilizzo</h2>
<p>Per distribuire il traffico ricevuto sull'interfaccia ifIN verso le interfacce ifOUT1, ifOUT2, ifOUT3 basta avviare il programma nel modo seguente </p>
<div class="fragment"><pre class="fragment">pfringbalancer -i ifIN -o ifOUT1 -o ifOUT2 -o ifOUT3
</pre></div><p> Possiamo anche scegliere tra le varie modalita' di dispatching se lo riteniamo necessario, la scelta di default e' il dispatching basato solo sull'ip sorgente e quello destinazione, in questo modo pacchetti appartenenti a connessioni diverse ma generati dagli stessi host usciranno dalla stessa interfaccia, se invece si desidera uno smistamento a grana piu' fine quindi a livello di flussi specifici possiamo aggiungere l'opzione "-m 1" </p>
<div class="fragment"><pre class="fragment">pfringbalancer -i ifIN -o ifOUT1 -o ifOUT2 -o ifOUT3 -m 1
</pre></div><h2><a class="anchor" id="build"></a>
Compilazione</h2>
<div class="fragment"><pre class="fragment">cmake .
make
</pre></div><h2><a class="anchor" id="working"></a>
Funzionamento Generale</h2>
<p>Il flusso d'esecuzione principale del programma consiste del parsing e verifica dei parametri in ingresso, contestualmente al parsing vengono inizializzate le interfacce in uscita, qual'ora ci fossero delle opzioni scorrette il programma libera le risorse gia' allocate stampa un messaggio di aiuto ed esce, se invece tutto va bene viene aperto il socket pf_ring sull'interfaccia in ingresso e comincia il loop di dispatching dei pacchetti, qual'ora il programma ricevesse un segnale di terminazione chiude le interfacce libera le risorse e termina, il diagramma sottostante riassume il flusso di esecuzione. </p>
<div class="image">
<img src="main.png" alt="main.png"/>
</div>
<p> La chiamata al metodo <a class="el" href="classBPFRD_1_1PacketDispatcher.html#a08ae011d21da3588cbc54c94099892e1" title="dispatch dispatch packet">BPFRD::PacketDispatcher::dispatch</a> interna al loop </p>
<div class="fragment"><pre class="fragment">dsp.dispatch( (<span class="keywordtype">char</span> *) buffer, &amp;hdr);
</pre></div><p> Racchiude al suo interno tutto il processo di dispatching di un pacchetto, ho scelto di non avviare thread paralleli per ciascun pacchetto per evitare i costi di sincronizzazione per l'accesso a strutture condivise ( per esempio la lista delle interfacce in uscita ), essendo comunque l'arrivo dei pacchetti sequenziale e l'obbiettivo la velocita' di smistamento, ho puntato sul velocizzare il piu' possibile l'operazione di dispatching invece che sull'eseguire piu' dispatching contemporaneamente ( che perde di senso dato l'esiguo costo di dispatching ). </p>
<div class="image">
<img src="dispatch.png" alt="dispatch.png"/>
</div>
<h2><a class="anchor" id="implementation"></a>
Scelte implementative</h2>
<h3><a class="anchor" id="programming_language"></a>
Linguaggio di programmazione</h3>
<p>Ho scelto C++ perche' permette di usare il paradigma di programmazione ad oggetti che mi ha facilitato molto nella strutturazione del programma con ottime prestazioni simili al C.</p>
<h3><a class="anchor" id="documentation"></a>
Strumento di Documentazione</h3>
<p>Ho scelto Doxygen perche' permette di scrivere la documentazione in linea e facilita la manutenibilita' e comprensibilita' del codice.</p>
<h3><a class="anchor" id="performances"></a>
Prestazioni</h3>
<p>Visto lo scopo del software ho scelto di ottimizzare ove possibile il codice, soprattutto le parti che vengono eseguite per ogni pacchetto da smistare.</p>
<h2><a class="anchor" id="optimizations"></a>
Ottimizzazioni</h2>
<p>Le ottimizzazioni di seguito trattate non sono in ordine di impatto.</p>
<h3><a class="anchor" id="inlining"></a>
Inlining Funzioni</h3>
<p>Per diminuire il piu' possibile i tempi di chiamata delle funzioni, ho scelto di dichiarare inline e scrivere in modo piu' compatto e ottimizzato possibile tutte le funzioni per cui fosse opportuno.</p>
<h3><a class="anchor" id="hashing"></a>
Hashing</h3>
<p>Il codice relativo all'hashing e' quello in cui le ottimizzazioni hanno un impatto maggiore.</p>
<dl class="user"><dt><b>Invocazione funzione di hashing selezionata</b></dt><dd>Invece di effettuare la scelta della funzione di hashing corretta tramite un if o un case ho preferito assegnare un puntatore a funzione nel costruttore di <a class="el" href="classBPFRD_1_1PacketDispatcher.html" title="Represent The Dispatcher.">BPFRD::PacketDispatcher</a> e usare quest'ultimo per invocare la funzione corretta in base alla scelta dell'utente, in questo modo qual'ora in futuro si aumentassero le modalita' di hashing disponibili il numero di cicli di clock per invocare la giusta funzione rimarrebbe costante.</dd></dl>
<dl class="user"><dt><b>Tabella Hash</b></dt><dd>Per accedere in tempo costante ai flussi vengono immagazzinati in una tabella hash, la gestione delle collisioni non e' necessaria per i nostri fini, tuttavia per poter ottimizzare pesantemente la funzione hash la tabella deve avere una dimensione potenza di 2.</dd></dl>
<dl class="user"><dt><b>Funzioni Hash</b></dt><dd>Essendo la tabella hash di dimensione potenza di 2 e non essendo necessarie garanzie stringenti sulle proprieta' della funzioni hash se non per il fatto che pacchetti di uno stesso flusso abbiano lo stesso hash ho potuto realizzarle componendo operatori base molto semplici e veloci quali xor bit a bit e somma, oltre a questo ogni riga di codice e' stata ponderata ed e' stato impiegato ogni possibile accorgimento per ottimizzare la funzione e diminuire la quantita' di codice assembler generato.<br/>
 Calcolo rapido dell'hash di un pacchetto IPv6: <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>ip6_hdr * ip6hdr = (ip6_hdr *)buffer + <span class="keyword">sizeof</span>(ether_header);
hash  = ip6hdr-&gt;ip6_src.s6_addr32[0] ^ ip6hdr-&gt;ip6_dst.s6_addr32[0];
hash += ip6hdr-&gt;ip6_src.s6_addr32[1] ^ ip6hdr-&gt;ip6_dst.s6_addr32[1];
hash += ip6hdr-&gt;ip6_src.s6_addr32[2] ^ ip6hdr-&gt;ip6_dst.s6_addr32[2];
hash += ip6hdr-&gt;ip6_src.s6_addr32[3] ^ ip6hdr-&gt;ip6_dst.s6_addr32[3];
</pre></div> Gestione compatta di pacchetti incapsulati VLAN <div class="fragment"><pre class="fragment"><span class="keywordflow">case</span> ETHERTYPE_VLAN:
{
        buffer += 4;
        minAcceptableLen += 4;
        eth_type = buffer[16];
        eth_type &lt;&lt;= 8;
        eth_type += buffer[17];
        <span class="keywordflow">goto</span> switch_ether;
}
</pre></div></dd></dl>
<h3><a class="anchor" id="code_substitution"></a>
Sostituzione del Codice</h3>
<p>Grazie alle macro di C/C++ e' possibile sostituire il codice a compile time, ho utilizzato questa feature per far <em>sparire</em> codice di debugging e di param checking in modo da ottimizzare ulteriormete le prestazioni, le opzioni da abilitare per far <em>riapparire</em> il codice sono specificare nel file CMakeLists.txt e sono CMAKE_BUILD_TYPE=Debug, BPFRD_DEBUG_LEVEL=x, BPFRD_FUNC_PARAMS_CHECKING. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 30 2013 13:20:30 for Balanced PF_RING Dispatcher by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
