--Chisels description

description = "This chisel get all the reads and the writes generated by the redis-server and for each command parsed from  argouments of these reads makes  some stats (supports inline commands)"

short_description = "List queries by parsing redis reads event "

category = "key value store"

--Chisels args
args = 
{
	{
		name = "verbose", 
		description = "allow or not verbose mode 0 no verbose mode allowed, 1 print only command, 2 print all", 
		argtype = "int"
	},
}


function on_set_arg(name, val)
	-- set the verbose mode, if the argoument is 1 the chisel stamp only the command if the argoument is 2 print all, command and argoument.
	verbosemode = tonumber(val)
	return true
end



-- Initialization callback
function on_init()
    -- Request the fields that we need
	 etype = chisel.request_field("evt.type")
	 eargs = chisel.request_field("evt.args")
	 etime = chisel.request_field("evt.reltime ")
	 earg = chisel.request_field("evt.arg[1]")
	 pname = chisel.request_field("proc.name")

    -- set the filter
    chisel.set_filter("proc.name = redis-server and (evt.type = read or evt.type = write ) and evt.dir = < ")

	 -- table that will contain the command and the time that the command spent to run
	 commandtable = {}
	 commandtimetable = {}
	 
    -- averaged time of command time run
	 difference = 0

	 -- variable that allow or not receiving command 
	 blocked = false

	 print("RedisQueriesStats is running, stop it (Ctrl+C) in every moment to see results.")

	 print()
    
	 -- this variable will be used to calculate the overall time of the life of this chisel
	 t1 = os.time()

    return true
end

-- Event parsing callback
function on_event()

	 -- if the event is a read 	 
	 if evt.field(etype) == "read" then
		-- if the command are allowed
		if(blocked == false) then
			-- I received a command, I don't allow new command until a write command is received
			blocked = true

			-- get the read time of the command
			rtime = tonumber(evt.field(etime))

			-- get the command by splitting args of the read
		  	commandname = mysplit(evt.field(earg), "%a+")[1]
			
			if commandname ~= nil then
					-- if verbose mode was active i print the command
					if (verbosemode == 1) then
						print(commandname)
					end
					if (verbosemode == 2) then
					-- if very verbose mode is allowed print all the argoument and the command
						print(evt.field(etype) .. " " .. evt.field(eargs))
					end

					-- if the command is into the table increment by one the counts altought set the counts to 1
				 	if commandtable[commandname] ~= nil then
						commandtable[commandname] = commandtable[commandname] + 1
				 	else commandtable[commandname] = 1
					end
			end
		end
	 else	
		if(rtime ~= nil) then
			-- if the command is a write, and if there was a read before that, this calulate the running time of the command
			if commandname ~= nil then
				blocked = false
				wtime = tonumber(evt.field(etime))
				difference = wtime - rtime
				-- if exists into the commandtimetable the command increment by 1 the value of commandtimetable[commandname]
			 	if commandtimetable[commandname] ~= nil then
					-- increment the sum of every run command time
					commandtimetable[commandname] = commandtimetable[commandname] + difference
				-- otherwise set commandtimetable[commandname] to difference
			 	else commandtimetable[commandname] = difference
				end
			end
	   end
	 end
end


-- End of capture callback
function on_capture_end()
	
	-- sec represents the execution time of the chisel
	sec = os.difftime(os.time(), t1)	

	print("")

	-- for every command in the table stamp the stats
	for i,item in pairs(commandtable) do
		print(i .. "--------------------------------")
      print("Number of " .. i .. ": " ..item)
		print("Command Rate per Second for " .. i .. " is: " .. item/sec)
		if commandtimetable[i] ~= nil then print("Average of time spent serving request is: " .. (commandtimetable[i]/item)/1000000 .. " milliseconds" )
		end
   end
end

-- split commands by sep and get the first word
function mysplit(inputstr, sep)
  	if sep == nil then
                sep = "%s"
  	end
   t={} ; i=1
   for str in string.gmatch(inputstr, sep) do
  		t[i] = str
      i = i + 1
   end
   return t
end

