--Chisels description

description = "This chisel get all the reads and the writes generated by the redis-server and for each command parsed from  argouments of these reads makes  some stats"

short_description = "List queries by parsing redis reads event "

category = "key value store"

--Chisels args
args = 
{
}



-- Initialization callback
function on_init()
    -- Request the fileds that we need
	 etype = chisel.request_field("evt.type")
	 eargs = chisel.request_field("evt.args")
	 etime = chisel.request_field("evt.reltime ")
	 earg = chisel.request_field("evt.arg[1]")
	 pname = chisel.request_field("proc.name")

    -- set the filter
    chisel.set_filter("proc.name = redis-server and (evt.type = read or evt.type = write ) and evt.dir = < ")

	 -- table that will contain the command and the time that the command spent to run
	 commandtable = {}
	 commandtimetable = {}
	 
    -- averaged time of command time run
	 difference = 0

	 print("RedisQueriesStats is running, stop it (Ctrl+C) in every moment to see results.")

	 print()
    
	 -- this variable will be used to calculate the overall time of the life of this chisel
	 t1 = os.time()

    return true
end

-- Event parsing callback
function on_event()

	 if evt.field(etype) == "read" then
		if(evt.field(earg):sub(1,1) == "*") then
			-- get the read time of the command
			rtime = tonumber(evt.field(etime))
			-- get the command by splitting args of the read
	  	 	commandname = mysplit(evt.field(earg), "%a+")[1]
			--TODO add verbose mode 
			print(commandname)
			if commandname ~= nil then
					-- if the command is into the table increment by one the counts altought set the counts to 1
				 	if commandtable[commandname] ~= nil then
						commandtable[commandname] = commandtable[commandname] + 1
				 	else commandtable[commandname] = 1
					end
			end
		end
	 else	
		if(rtime ~= nil) then
			-- if the command is a write if there was a read after this calulate the time run of the command
			if commandname ~= nil then
				allowed = true
				wtime = tonumber(evt.field(etime))
				difference = wtime - rtime
				--TODO verbose print(commandname .. " " .. tostring(wtime) .. " - " .. tostring(rtime) .. " = ".. tostring(difference) )
			 	if commandtimetable[commandname] ~= nil then
					-- increment the sum of every run command time
					commandtimetable[commandname] = commandtimetable[commandname] + difference
			 	else commandtimetable[commandname] = difference
				end
			end
	   end
		--TODO verbose mode print(evt.field(etype) .. " " .. evt.field(eargs))
	 end
end


-- End of capture callback
function on_capture_end()
	
	sec = os.difftime(os.time(), t1)	

	print("")
	-- for every command in the table stamp the stats
	for i,item in pairs(commandtable) do
		print(i .. "--------------------------------")
      print("Number of " .. i .. ": " ..item)
		print("Fork Rate per Second for " .. i .. " is: " .. item/sec)
		if commandtimetable[i] ~= nil then print("Average of time spent serving request is: " .. commandtimetable[i]/item .. " nanoseconds" )
		end
   end
end

-- split commands by sep and get the first word
function mysplit(inputstr, sep)
  	if sep == nil then
                sep = "%s"
  	end
   t={} ; i=1
   for str in string.gmatch(inputstr, sep) do
  		t[i] = str
      i = i + 1
   end
   return t
end

-- check if the commandname is into a table
function isIn(commandname, table)
	if table ~= nil then
		if table[commandname] == nil then
			return false
		else return true
		end
	end
	return false
end

-- check if a string contains lower character or is upper string
function checkLowerString(sstring)
	if sstring:upper() == sstring then return false
	else return true
	end
end
